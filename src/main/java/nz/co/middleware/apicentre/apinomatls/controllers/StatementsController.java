/*
 * AccountAndTransactionAPISpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package nz.co.middleware.apicentre.apinomatls.controllers;

import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import nz.co.middleware.apicentre.apinomatls.ApiHelper;
import nz.co.middleware.apicentre.apinomatls.DateTimeHelper;
import nz.co.middleware.apicentre.apinomatls.Server;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatements400ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatements403ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatements500ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatements503ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatementsTransactions400ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatementsTransactions403ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatementsTransactions500ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.AccountsStatementsTransactions503ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.ApiException;
import nz.co.middleware.apicentre.apinomatls.exceptions.Statements400ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.Statements403ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.Statements500ErrorException;
import nz.co.middleware.apicentre.apinomatls.exceptions.Statements503ErrorException;
import nz.co.middleware.apicentre.apinomatls.http.request.HttpMethod;
import nz.co.middleware.apicentre.apinomatls.models.GetAccountStatementResponse;
import nz.co.middleware.apicentre.apinomatls.models.GetAccountStatementTransactionsResponse;
import nz.co.middleware.apicentre.apinomatls.models.GetAccountStatementsResponse;
import nz.co.middleware.apicentre.apinomatls.models.GetStatementsResponse;

/**
 * This class lists all the endpoints of the groups.
 */
public final class StatementsController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public StatementsController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Get Statement related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  statementId  Required parameter: A unique identifier used to identify the statement
     *         resource.
     * @param  fromStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements FROM NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  toStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetAccountStatementResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public GetAccountStatementResponse getAccountStatement(
            final String accountId,
            final String statementId,
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws ApiException, IOException {
        return prepareGetAccountStatementRequest(accountId, statementId, fromStatementDateTime,
                toStatementDateTime, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId,
                xMerchantIpAddress, xCustomerUserAgent).execute();
    }

    /**
     * Get Statement related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  statementId  Required parameter: A unique identifier used to identify the statement
     *         resource.
     * @param  fromStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements FROM NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  toStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetAccountStatementResponse response from the API call
     */
    public CompletableFuture<GetAccountStatementResponse> getAccountStatementAsync(
            final String accountId,
            final String statementId,
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) {
        try { 
            return prepareGetAccountStatementRequest(accountId, statementId, fromStatementDateTime,
            toStatementDateTime, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId,
            xMerchantIpAddress, xCustomerUserAgent).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getAccountStatement.
     */
    private ApiCall<GetAccountStatementResponse, ApiException> prepareGetAccountStatementRequest(
            final String accountId,
            final String statementId,
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws IOException {
        return new ApiCall.Builder<GetAccountStatementResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/accounts/{AccountId}/statements/{StatementId}")
                        .queryParam(param -> param.key("fromStatementDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(fromStatementDateTime)).isRequired(false))
                        .queryParam(param -> param.key("toStatementDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(toStatementDateTime)).isRequired(false))
                        .templateParam(param -> param.key("AccountId").value(accountId)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("StatementId").value(statementId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("x-fapi-auth-date")
                                .value(xFapiAuthDate).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-customer-ip-address")
                                .value(xFapiCustomerIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-interaction-id")
                                .value(xFapiInteractionId).isRequired(false))
                        .headerParam(param -> param.key("x-merchant-ip-address")
                                .value(xMerchantIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-customer-user-agent")
                                .value(xCustomerUserAgent).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("HTTPBearerAuthentication"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, GetAccountStatementResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request",
                                (reason, context) -> new AccountsStatements400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new AccountsStatements403ErrorException(reason, context)))
                        .localErrorCase("405",
                                 ErrorCase.setReason("Method Not Allowed",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.setReason("Not Acceptable",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("Too Many Requests",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server Error",
                                (reason, context) -> new AccountsStatements500ErrorException(reason, context)))
                        .localErrorCase("501",
                                 ErrorCase.setReason("Not Implemented",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service Unavailable",
                                (reason, context) -> new AccountsStatements503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get Statement related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  statementId  Required parameter: A unique identifier used to identify the statement
     *         resource.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object getAccountStatementFile(
            final String accountId,
            final String statementId,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws ApiException, IOException {
        return prepareGetAccountStatementFileRequest(accountId, statementId, xFapiAuthDate,
                xFapiCustomerIpAddress, xFapiInteractionId, xMerchantIpAddress,
                xCustomerUserAgent).execute();
    }

    /**
     * Get Statement related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  statementId  Required parameter: A unique identifier used to identify the statement
     *         resource.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> getAccountStatementFileAsync(
            final String accountId,
            final String statementId,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) {
        try { 
            return prepareGetAccountStatementFileRequest(accountId, statementId, xFapiAuthDate,
            xFapiCustomerIpAddress, xFapiInteractionId, xMerchantIpAddress,
            xCustomerUserAgent).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getAccountStatementFile.
     */
    private ApiCall<Object, ApiException> prepareGetAccountStatementFileRequest(
            final String accountId,
            final String statementId,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/accounts/{AccountId}/statements/{StatementId}/file")
                        .templateParam(param -> param.key("AccountId").value(accountId)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("StatementId").value(statementId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("x-fapi-auth-date")
                                .value(xFapiAuthDate).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-customer-ip-address")
                                .value(xFapiCustomerIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-interaction-id")
                                .value(xFapiInteractionId).isRequired(false))
                        .headerParam(param -> param.key("x-merchant-ip-address")
                                .value(xMerchantIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-customer-user-agent")
                                .value(xCustomerUserAgent).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("HTTPBearerAuthentication"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("405",
                                 ErrorCase.setReason("Method Not Allowed",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.setReason("Not Acceptable",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("Too Many Requests",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server Error",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("501",
                                 ErrorCase.setReason("Not Implemented",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service Unavailable",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get Statement Transactions related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  statementId  Required parameter: A unique identifier used to identify the statement
     *         resource.
     * @param  fromBookingDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         transactions FROM NB Time component is optional - set to 00:00:00 for just Date. If
     *         the Date Time contains a timezone, the API Provider must ignore the timezone
     *         component.
     * @param  toBookingDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         transactions TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetAccountStatementTransactionsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public GetAccountStatementTransactionsResponse getAccountStatementTransactions(
            final String accountId,
            final String statementId,
            final LocalDateTime fromBookingDateTime,
            final LocalDateTime toBookingDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws ApiException, IOException {
        return prepareGetAccountStatementTransactionsRequest(accountId, statementId,
                fromBookingDateTime, toBookingDateTime, xFapiAuthDate, xFapiCustomerIpAddress,
                xFapiInteractionId, xMerchantIpAddress, xCustomerUserAgent).execute();
    }

    /**
     * Get Statement Transactions related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  statementId  Required parameter: A unique identifier used to identify the statement
     *         resource.
     * @param  fromBookingDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         transactions FROM NB Time component is optional - set to 00:00:00 for just Date. If
     *         the Date Time contains a timezone, the API Provider must ignore the timezone
     *         component.
     * @param  toBookingDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         transactions TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetAccountStatementTransactionsResponse response from the API call
     */
    public CompletableFuture<GetAccountStatementTransactionsResponse> getAccountStatementTransactionsAsync(
            final String accountId,
            final String statementId,
            final LocalDateTime fromBookingDateTime,
            final LocalDateTime toBookingDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) {
        try { 
            return prepareGetAccountStatementTransactionsRequest(accountId, statementId,
            fromBookingDateTime, toBookingDateTime, xFapiAuthDate, xFapiCustomerIpAddress,
            xFapiInteractionId, xMerchantIpAddress, xCustomerUserAgent).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getAccountStatementTransactions.
     */
    private ApiCall<GetAccountStatementTransactionsResponse, ApiException> prepareGetAccountStatementTransactionsRequest(
            final String accountId,
            final String statementId,
            final LocalDateTime fromBookingDateTime,
            final LocalDateTime toBookingDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws IOException {
        return new ApiCall.Builder<GetAccountStatementTransactionsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/accounts/{AccountId}/statements/{StatementId}/transactions")
                        .queryParam(param -> param.key("fromBookingDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(fromBookingDateTime)).isRequired(false))
                        .queryParam(param -> param.key("toBookingDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(toBookingDateTime)).isRequired(false))
                        .templateParam(param -> param.key("AccountId").value(accountId)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("StatementId").value(statementId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("x-fapi-auth-date")
                                .value(xFapiAuthDate).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-customer-ip-address")
                                .value(xFapiCustomerIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-interaction-id")
                                .value(xFapiInteractionId).isRequired(false))
                        .headerParam(param -> param.key("x-merchant-ip-address")
                                .value(xMerchantIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-customer-user-agent")
                                .value(xCustomerUserAgent).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("HTTPBearerAuthentication"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, GetAccountStatementTransactionsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request",
                                (reason, context) -> new AccountsStatementsTransactions400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new AccountsStatementsTransactions403ErrorException(reason, context)))
                        .localErrorCase("405",
                                 ErrorCase.setReason("Method Not Allowed",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.setReason("Not Acceptable",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("Too Many Requests",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server Error",
                                (reason, context) -> new AccountsStatementsTransactions500ErrorException(reason, context)))
                        .localErrorCase("501",
                                 ErrorCase.setReason("Not Implemented",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service Unavailable",
                                (reason, context) -> new AccountsStatementsTransactions503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get Statements related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  fromStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements FROM NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  toStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetAccountStatementsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public GetAccountStatementsResponse getAccountStatements(
            final String accountId,
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws ApiException, IOException {
        return prepareGetAccountStatementsRequest(accountId, fromStatementDateTime,
                toStatementDateTime, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId,
                xMerchantIpAddress, xCustomerUserAgent).execute();
    }

    /**
     * Get Statements related to an account.
     * @param  accountId  Required parameter: A unique identifier used to identify the account
     *         resource.
     * @param  fromStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements FROM NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  toStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetAccountStatementsResponse response from the API call
     */
    public CompletableFuture<GetAccountStatementsResponse> getAccountStatementsAsync(
            final String accountId,
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) {
        try { 
            return prepareGetAccountStatementsRequest(accountId, fromStatementDateTime, toStatementDateTime,
            xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xMerchantIpAddress,
            xCustomerUserAgent).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getAccountStatements.
     */
    private ApiCall<GetAccountStatementsResponse, ApiException> prepareGetAccountStatementsRequest(
            final String accountId,
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws IOException {
        return new ApiCall.Builder<GetAccountStatementsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/accounts/{AccountId}/statements")
                        .queryParam(param -> param.key("fromStatementDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(fromStatementDateTime)).isRequired(false))
                        .queryParam(param -> param.key("toStatementDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(toStatementDateTime)).isRequired(false))
                        .templateParam(param -> param.key("AccountId").value(accountId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("x-fapi-auth-date")
                                .value(xFapiAuthDate).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-customer-ip-address")
                                .value(xFapiCustomerIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-interaction-id")
                                .value(xFapiInteractionId).isRequired(false))
                        .headerParam(param -> param.key("x-merchant-ip-address")
                                .value(xMerchantIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-customer-user-agent")
                                .value(xCustomerUserAgent).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("HTTPBearerAuthentication"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, GetAccountStatementsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request",
                                (reason, context) -> new AccountsStatements400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new AccountsStatements403ErrorException(reason, context)))
                        .localErrorCase("405",
                                 ErrorCase.setReason("Method Not Allowed",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.setReason("Not Acceptable",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("Too Many Requests",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server Error",
                                (reason, context) -> new AccountsStatements500ErrorException(reason, context)))
                        .localErrorCase("501",
                                 ErrorCase.setReason("Not Implemented",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service Unavailable",
                                (reason, context) -> new AccountsStatements503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get Statements.
     * @param  fromStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements FROM NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  toStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetStatementsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public GetStatementsResponse getStatements(
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws ApiException, IOException {
        return prepareGetStatementsRequest(fromStatementDateTime, toStatementDateTime,
                xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xMerchantIpAddress,
                xCustomerUserAgent).execute();
    }

    /**
     * Get Statements.
     * @param  fromStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements FROM NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  toStatementDateTime  Optional parameter: The UTC ISO 8601 Date Time to filter
     *         statements TO NB Time component is optional - set to 00:00:00 for just Date. If the
     *         Date Time contains a timezone, the API Provider must ignore the timezone component.
     * @param  xFapiAuthDate  Optional parameter: The time when the Customer last logged in with the
     *         Third Party. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An
     *         example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param  xFapiCustomerIpAddress  Optional parameter: The Customer's IP address if the Customer
     *         is currently logged in with the Third Party.
     * @param  xFapiInteractionId  Optional parameter: An RFC4122 UID used as a correlation id.
     * @param  xMerchantIpAddress  Optional parameter: The IP address of the merchant when making
     *         account information requests through a Third Party.
     * @param  xCustomerUserAgent  Optional parameter: The User-Agent of the application on the
     *         customer device that is used to make the account information request
     * @return    Returns the GetStatementsResponse response from the API call
     */
    public CompletableFuture<GetStatementsResponse> getStatementsAsync(
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) {
        try { 
            return prepareGetStatementsRequest(fromStatementDateTime, toStatementDateTime, xFapiAuthDate,
            xFapiCustomerIpAddress, xFapiInteractionId, xMerchantIpAddress,
            xCustomerUserAgent).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getStatements.
     */
    private ApiCall<GetStatementsResponse, ApiException> prepareGetStatementsRequest(
            final LocalDateTime fromStatementDateTime,
            final LocalDateTime toStatementDateTime,
            final String xFapiAuthDate,
            final String xFapiCustomerIpAddress,
            final String xFapiInteractionId,
            final String xMerchantIpAddress,
            final String xCustomerUserAgent) throws IOException {
        return new ApiCall.Builder<GetStatementsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/statements")
                        .queryParam(param -> param.key("fromStatementDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(fromStatementDateTime)).isRequired(false))
                        .queryParam(param -> param.key("toStatementDateTime")
                                .value(DateTimeHelper.toRfc8601DateTime(toStatementDateTime)).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-auth-date")
                                .value(xFapiAuthDate).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-customer-ip-address")
                                .value(xFapiCustomerIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-fapi-interaction-id")
                                .value(xFapiInteractionId).isRequired(false))
                        .headerParam(param -> param.key("x-merchant-ip-address")
                                .value(xMerchantIpAddress).isRequired(false))
                        .headerParam(param -> param.key("x-customer-user-agent")
                                .value(xCustomerUserAgent).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("HTTPBearerAuthentication"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, GetStatementsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request",
                                (reason, context) -> new Statements400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new Statements403ErrorException(reason, context)))
                        .localErrorCase("405",
                                 ErrorCase.setReason("Method Not Allowed",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("406",
                                 ErrorCase.setReason("Not Acceptable",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("Too Many Requests",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("Internal Server Error",
                                (reason, context) -> new Statements500ErrorException(reason, context)))
                        .localErrorCase("501",
                                 ErrorCase.setReason("Not Implemented",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.setReason("Service Unavailable",
                                (reason, context) -> new Statements503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}